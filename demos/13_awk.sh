#!/bin/bash

# 第十三章：awk
# 
# 1. awk介绍
# awk是一种用于处理文本的编程语言工具。awk本身就是linux下的一个工具，既可以单独使用，也可以嵌入到bash中。
# awk语言的最基本功能是在文件或字符串中基于指定规则浏览和抽取信息。 awk抽取信息后,才能进行其他文本操作。完整的 awk脚本通常用来格式化文本文件中的信息。
#
# 2. awk环境变量
#  -------------------------------------------------------------
#  |  变量        |    说明                                    |
#  |--------------|--------------------------------------------|
#  |  $n          |  当前记录的第n个字段，字段由FS分隔         |           
#  |  $0          |  完整的输入记录                            |
#  |  ARGC        |  命令行参数的数目                          | 
#  |  ARGIND      |  命令行中当前文件的位置(从0开始算)         |               
#  |  ARGV        |  包含命令行参数的数组                      |  
#  |  CONVFMT     |  数字转换格式(默认是%.6g)                  | 
#  |  ENVIRON     |  环境变量关联数组                          |   
#  |  ERRNO       |  最后一个系统错误的描述                    |    
#  |  FIELDWIDTHS |  字段宽度列表(用空格键分隔)                |   
#  |  FILENAME    |  当前文件名                                |       
#  |  FNR         |  同NR，当FNR是相对于当前文件而言           |        
#  |  FS          |  字段分隔符(默认是任意的空格符)            |       
#  |  IGNORECASE  |  若为真，则匹配时忽略大小写                |        
#  |  NF          |  当前记录中的字段数                        |          
#  |  NR          |  已读的记录数                              |         
#  |  OFMT        |  数字的输出格式(默认是%.6g)                |   
#  |  OFS         |  输出域分隔符(默认是一个空格)              |          
#  |  ORS         |  输出记录分隔符(默认是一个换行符)          |         
#  |  RLENGTH     |  由match函数所匹配的字符串的长度           |        
#  |  RS          |  控制记录分隔符(默认是一个换行符)          |         
#  |  RSTART      |  由match函数所匹配的字符串的第一个位置     |              
#  |  SUBSEP      |  数字下标分隔符(默认值是\034)              |     
#  |-----------------------------------------------------------|
#
# 3. awk条件操作符
#  ---------------------------------------
#  | 符号 |     描述                     |
#  |------|------------------------------|
#  |  <   |  小于                        |      
#  |  <=  |  小于或等于                  |            
#  |  ==  |  等于                        |      
#  |  !=  |  不等于                      |        
#  |  >=  |  大于或等于                  |            
#  |  >   |  大于                        |      
#  |  !   |  匹配正则表达式              |                
#  |  !~  |  不匹配正则表达式            |                  
#  |-------------------------------------|
#
# 4. awk字符串操作
#  -----------------------------------------------------------------
#  |  表达式          |    说明                                    |
#  |------------------|--------------------------------------------|
#  |  gsub(r,s)       |  在整个$0中用s替换r                        |        
#  |  gsub(r,s,t)     |  在整个t中用s替换r                         |       
#  |  index(s,t)      |  返回s中字符串t的第一个位置                |                
#  |  length(s)       |  返回s的长度                               | 
#  |  match(s,r)      |  测试s是否包含匹配r的字符串                |                
#  |  split(s,a,fs)   |  在fs上将s分成序列a                        |        
#  |  sprint(fmt,exp) |  返回经fmt格式化后的exp                    |            
#  |  sub(r,s)        |  用$0中最左边最长的子串代替s               |                 
#  |  substr(s,p)     |  返回字符串s中从p开始的后缀部分            |                    
#  |  substr(s,p,n)   |  返回字符串s中从p开始的长度为n后缀部分     |                           
#  |---------------------------------------------------------------|
#
# 5. 正则表达式中常用类
#  -----------------------------------------------
#  | 表达式       |     描述                     |
#  |--------------|------------------------------|
#  | [[:upper:]]  |  [A-Z]                       |
#  | [[:lower:]]  |  [a-z]                       |
#  | [[:alpha:]]  |  [a-zA-Z]                    |   
#  | [[:digit:]]  |  [0-9]                       |
#  | [[:alnum:]]  |  [0-9a-zA-Z]                 |      
#  | [[:space:]]  |  空格或tab键                 |      
#  |---------------------------------------------|



# 实例：首先建立一个ori.txt，添加任意文本，然后进行以下练习。
# (01), 输出文件全部文本
awk '{print $0}' ori.txt
# 说明:
#   {}：表示一段awk命令。
#   print：输出指令。
#   $0：当前行的全部文本。
#   awk工具操作文件时，是以行为单位，逐步对每行进行操作。拿本例来说{print $0}，意味着“对每一行都执行print $0操作，即输出每一行的全部文本”。
#   $N：当N>1时，$N表示当前行的第N段；每一行中以FS(默认值是空格)来分段。

# (02), 输出"ls -l"中每行的field1、field9
ls -l | awk '{printf("%s %s\n", $1, $9)}'
# 说明:
#   |：管道符号。表示将“前面指令的输出”作为“后面指令的输入”，即将“ls -l”的输出作为“awk”的输入。
#   printf：输出指令。它的使用方法和C语言中printf的使用方法一样。
#   $1：该行的第1段。
#   $9：该行的第9端。

# (03), 在上一题的基础上添加功能：第一，输出每一行的行号和该行所包括的域的总数。第二，第1行和最后一行输出提示语
ls -l | awk 'BEGIN{printf("----begin----\n")} {printf("Line-%3d Field-%d : %s %s\n", NR, NF, $1, $9)} END{printf("----end----\n")}'
# 说明：
#   BEGIN：表示在文本进行操作之前进行的工作。
#   END：表示在对文本的所有行都处理完毕之后前进行的工作。
#   在awk中，请尽量使用{}来进行区分指令段，{}可以嵌套使用！这样做的好处写出的脚本不容易出错，而且可读性更强！

# (04), 输出"ls -l"中文件(夹)名字包括数字的完整信息
ls -l | awk '{if($9 ~ /[[:digit:]]/) {print $0}}'
# 说明：
#   $9 ~ /[[:digit:]]/ ： 表示能够匹配数字的“第一行的第9段”。

# (05), 输出"ls -l"中非文件夹的完整信息
ls -l | awk '{if($1 !~ /^d/) {print $0}}'
# 说明：
#   ^d ： 以d开头的。^表示起始位。此外，$表示结束位。如d$，表示以d结尾的。

# (06), 找到"ls -l"中文件(夹)名字的长度大于10的行，然后输出其完整信息。
ls -l | awk '{if(length($9) > 10) {print $0}}'

# (07), 如何给文本的每一行添加行号？
awk '{printf("%03d %s\n",NR, $0)}' ori.txt > dst.txt

# (08), 打印字段数大于3的行的总数
awk 'BEGIN{COUNT=0}; {if(NF>3) COUNT++}; END{printf("COUNT=%d\n", COUNT)}' ori.txt

# (09), 将文本中的各行合并一行，中间用“|”分割
awk 'BEGIN{ORS="|"}{print $0 }END{print "\n"}' ori.txt > dst.txt
# 说明：
#  ORS：表示记录分割符，每条记录表示每行。ORS默认值为换行符。

# (10), 将文本中空格换成换行符
awk 'BEGIN{FS=" ";OFS="\n"}{print $1 }END{print "\n"}' ori.txt > dst.txt

# (11), 将3行合并成一行，并输入行号
awk 'BEGIN{ORS="";i=0}{ j=1; while(j<=NF){ if(i%3==0){printf("%02d ",i/3+1)}; printf("%s ",$j); i++; j++; if(i%3==0){print "\n"} }} END{print "\n"}' ori.txt > dst.txt

